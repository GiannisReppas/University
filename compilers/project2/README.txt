Ονοματεπώνυμο: Γιάννης Ρέππας
Α.Μ.: 1115201500137
README.txt αρχείο για project2 compilers

/////// Makefile ////////

make clean -> διαγραφή περιτών αρχείων (.class αρχεία)
make compile ή make all -> μεταγλώττιση κώδικα (τα jar αρχεία πρέπει να βρίσκονται έναν φάκελο έξω από τη Main.java) (όλα τα υπόλοιπα αρχεία πρέπει να βρίσκονται στον ίδιο φάκελο με τη Main.java)
java Main αρχείο1 αρχείο2 .... -> εκτέλεση

/////////////////// symbol table: ////////////////////////

Για sumbol table χρησιμοποιήθηκε μια δική μου δομή, που στην ουσία μοιάζει κατά κάποιο τρόπο με το dom της html. Αποτελείται από μία λίστα από classNodes.

classNode {
	String name;
	boolean extendClass;
	LinkedList<String> children = new LinkedList<String>();
	LinkedList<AttributeNode> attributes = new LinkedList<AttributeNode>();
	LinkedList<MethodNode> methods = new LinkedList<MethodNode>();
}

, όπου name το όνομα της κλάσης, extendClass μία boolean μεταβλητή που είναι true σε περίπτωση που η κλάση κληρονομεί τα πεδία και τις συναρτήσεις μίας άλλης κλάσης, children μία λίστα με τα ονόματα των παιδιών της κλάσης και μάλιστα όχι μόνο σε επίπεδο παιδιών, αλλά και σε κατώτερα επίπεδα, π.χ. αν είχαμε class A {} class B extends A {} και class C extends B {}, τότε η λίστα με τα παιδιά της Α θα είχε δύο στοιχεία: Β,C. Η λίστα attributes είναι μια λίστα με όλες τις μεταβλητές της κλάσης και η λίστα methods είναι μια λίστα με όλες τις μεθόδους της κλάσης.
Το κάθε classNode λοιπόν έχει μία λίστα με όλες τις μεταβλητές και τις μεθόδους της κλάσης στην οποία ανφέρεται.
Οπότε το AttributeNode έχει την εξής δομή:

attributeNode {
	String type;
	String name;
	boolean offsetInclude;
}

και το MethodNode έχει την εξής δομή {
	String type;
	String name;
	boolean offsetInclude;
	LinkedList<AttributeNode> parameters = new LinkedList<AtttributeNode>();
	LinkedList<AttributeNode> variables = new LinkedList<AttributeNode>();
}

Η μεταβλητή offsetInclude είναι μία boolean μεταβλητή που χρησιμοποιείται για να γνωρίζουμε κατά τον υπολογισμό των offsets αν η μετβαλητή ή η μέθοδος πρέπει να ληφθεί υπόψην.
Οπότε, σε περίπτώσεις δηλώσεων μεταβλητών ή παραμέτρων στο σώμα μιας μεθόδου, αλλά και σε περιπτώσεις κληρονομικότητας πεδίων ή συναρτήσεων από μία κλάση σε μία άλλη, η μεταβλητή αυτή είναι false.

/////////////// STPVisitor.java: /////////////////////

Σε αυτόν τον visitor γίνεται initialize η δομή του symbol table. Στην ουσία, επισκεπτόμαστε όλες τις δηλώσεις κλάσων, μεθόδων και μεταβλητών και τις αποθηκεύουμε στο symbol table.
Γνωρίζουμε πάντα σε ποια κλάση και σε ποια μέθοδο βρισκόμαστε και αυτή είναι η τελευταία που έχουμε αποθηκευμένη στη λίστα του symbol table.
Επομένως, για κάθε δήλωση που έχουμε, παίρνουμε τον τύπο και το όνο της μεταβλητής/μεθόδου και το αποθηκεύουμε.
Πριν την κάθε αποθήκευση, εξετάζουμε πάντα αν το στοιχείο που αποθηκεύουμε είναι μοναδικό ως προς το όνομά του στο scope μέσα στο οποίο ορίζεται.
Σε περίπτωση που έχουμε κληρονομικότητα, μετά τη δήλωση όλων των πεδίων της κλάσης στο symbol table, κάνουμε copy όλα τα στοιχεία της κλάσης που επεκτείνεται, στην τελευταία κλάση του symbol table, δηλαδή στην κλάση που επισκεπτόμστε.
Οπότε, αν είχαμε το παρακάτω παράδειγμα:

class A { int i; int foo() {} }

class B extends A { int a; int foo() { boolean h; } }

αρχικά θα αποθηκεύαμε την κλάση B στο symbol table, μαζί με το field a και μαζί με τη συνάρτηση foo και στη συνέχεια θα κάναμε copy όλες τις πληροφορίες της κλάσης A στην κλάση Β, δηλαδή μόνο τη μεταβλητή i, αφού η μέθοδος foo επαναορίζεται στην κλάση B.  Ωστόσο, το πεδίο offsetInclude στον ορισμό του i στο symbol table θα είναι false, σε αντίθεση με το a που θα είναι true, μιας και το i χει ήδη προστεθεί ως true στην κλάση Α.

Τέλος, στη συνάρτηση printOffsets() γίνεται ο υπολογισμός και η εκτύπωση των offsets του κάθε inheritance tree που ορίζεται στο αρχείο java που δίνουμε σαν είσοδο.
Για κάθε κλάση η οποία δεν κάνει extend κάποια άλλη κλάση (extendClass -> false), καλούμε τη συνάρτηση printInheritanceTree(), η οποία ξεκινόντας από τα πεδία της κλάσης που της δίνουμε, εκτυπώνει τα offsets της και στη συνέχεια προχωράει στην εκτύπωση των offsets της κάθε κλάσης που ανήκει στη λίστα των παιδιών της.
Όμως, όπως αναφέρθηκε και πιο πάνω, η λίστα αυτή δεν περιέχει στην ουσία μόνο παιδιά για την κάθε κλάση, αλλά και παιδιά των παιδιών της κ.ο.κ.
Επομένως, αν προχωρήσουμε σε κλήση της συνάρτησης και για αυτά τα "παιδιά" της κλάσης, θα έχουμε διπλή εκτύπωση των offsets και μάλιστα λανθασμένη για ορισμένες κλήσεις.
Αυτό το πρόβλημα το λύνουμε κρατώντας μία λίστα με το σύνολο των κλάσεων που έχουν εκτυπωθεί και βγάζοντας από αυτήν τη λίστα κάθε φορά το όνομα της κλάσης που εκτυπώθηκε.
Είμαστε σίγουροι ότι η κλήση που θα γίνει πρώτα θα είναι και αυτή που θέλουμε, αφού η minijava δεν επιτρέπει μια κλάση να οριστεί πριν από την κλάση που κάνει extend και επίσης ο τρόπος με τον οποίο καλούμε τη printInheritanceTree είναι μια παραλλαγή της DFS.

Αν για παράδειγμα δηλαδή είχαμε

class A {}

class B extends A {}

class C extends B {}

, τότε θα είχαμε μία κλήση printInheritanceTree(A)
, μετά μια κλήση printInheritanceTree(B)
, μετά μια κλήση printInheritanceTree(C), όπου C παιδί της Β
και τέλος μια κλήση printInheritanceTree(C), όπου C παιδί της Α, η οποία όμως δεν θα εκτελεστεί ποτέ, αφού η C έχει εκτυπωθεί ήδη

///////////////////// TCVisitor.java /////////////////////

Ο TCVisitor χρησιμοποιείται για τον έλεγχο των statements και των expressions στο mini java πρόγραμμα που έχουμε σαν είσοδο.

Αρχικά, ο TCVisitor έχει μέσα του σαν μεταβλητή έναν STPVisitor έτσι ώστε να έχουμε πρόσβαση στο symbol table.
Επίσης, στον constructor του TCVisitor, κάνουμε έλεγχο όλους τους τύπους μεθόδων και μεταβλητών που δεν είναι int ή boolean, για να δούμε αν ο τύπος της κλάσης που ορίστηκε υπάρχει στο πρόγραμμα.
Κάτι τέτοιο γίνετια μετά τον STPVisitor, επειδή η mini java επιτρέπει farward declarations, επομένως θα μπορούσαμε να ορίζαμε μια μεταβλητή A one, με την κλάση A να ορίζεται μετά την μεταβλητή one.

Μέσα στον TCVisitor έχουν οριστεί κατάλληλες συναρτήσεις, οι οποιές παίρνοντας σαν ορίσματα την τοποθεσία μια μεταβλητήσς μέσα στο symbol table, επιστρέφουν τον τύπο της.
Επίσης, έχει οριστεί και η συνάρτηση isChild(string b, string a), η οποία επιστρέφει true, αν η κλάση b ανήκει στη λίστα των παιδιών της κλάσης a

Οπότε λοιπόν, για κάθε μεταβλητή ή σταθερά που βλέπουμε, χρησιμοποιούμε αυτές τις συναρτήσεις και ελέγχουμε αν ο τύπος είναι ή όχι ο επιθυμητός, ανάλογα με αυτόν που περιμένουμε στο κάθε stetement/expression

Για αναλυτικότερη τεκμηρίωση του κώδικα μπορείτε να δείτε τα σχόλια του προγράμματος.