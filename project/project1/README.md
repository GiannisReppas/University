Γιάννης Ρέππας - 1115201500137
Γιάννης Τασσόπουλος - 1115201500155
Αλέξανδρος Πολυχρονόπουλος - 1115201600138

arrays.py:

Το αρχείο arrays.py φτιάχτηκε για να δημιουργεί αρχεία για την είσοδο του προγράμματος smj.exe . Ο τρόπος με τον οποίο καλείται είναι: python arrays.py rowsForArray1 rowsForArray2 και τα αρχεία τα οποία παράγονται είναι τα input1.csv και input2.csv . Το κάθε στοιχείο του πίνακα χωρίζεται με το επόμενο στην ίδια γραμμή με ένα κόμμα(,) . Αρχικά στο arrays.py γίνεται έλεγχος για τη σωστή κλήση του αρχείου και μετά ( εφόσον η κλήση του έγινε όντως σωστά) διαγράφονται τα προηγούμενα αρχεία input1.csv και input2.csv . Στη συνέχεια, χρησιμοποιώντας τη συνάρτηση random.randint() παράγουμε τυχαίους αριθμούς, με τον μικρότερο να μπορεί να είναι το 0 και το μεγαλύτερο να μπορεί να είναι το 18446744073709551615(μεγαλύτερος uint64_t). Παρ' όλα αυτά, η συνάρτηση random.randomint() το πιο πιθανό είναι να παράξει και για τα δύο αρχεία διαφορετικούς αριθμούς, ανεξάρτητα από το μέγεθος των πινάκων. Γι'αυτό λοιπόν, από το αποτέλσμα της συνάρτησης random.randomint(), παίρνουμε το υπόλοιπό του με το 100, έτσι ώστε να λύσουμε αυτό το πρόβλημα. Βέβαια, με αυτόν τον τρόπο δε θα έχουμε στον τελικό πίνακα αριθμούς μεγαλύτερους του 100. Για αυτό το λόγο είναι στην ελευθερία του χρήστη να αλλάξει το πρόγραμμα και να βάλει, εάν το επιθυμεί, το δικό του άνω όριο στα στοιχεία του πίνακα, έχοντας βέβαια στο πίσω μέρος του μυαλού του πως όσο μεγαλύτερο είναι το άνω όριο, τόσο μεγαλύτερη θα είναι και η πιθανότητα να μην υπάρχουν στοιχεία για να γίνει mergeJoin. Έκδοση python -> 2.7

main.c:

Το αρχείο main.c περιέχει τη συνάρτηση main του προγράμματος, τη συνάρτηση που διαβάζει τα αρχεία εισόδου και δημιουργεί τις σχέσεις R και S και 2 συναρτήσεις για την εκτύπωση των αποτελεσμάτων από τη λίστα (printData) και για την ελευθέρωση της μνήμης από τη λίστα. Η main αρχικά καλεί 2 φορές την create relation, μία για κάθε αρχείο που δόθηκε από το command line. Θεωρούμε ότι το αρχείο που δόθηκε έχει τη σωστή δομή, δηλαδή 2 στήλες, η μία με το key και η δεύτερη με το payload. Αφού δημιουργηθούν οι δύο πίνακες R και S, καλείται η συνάρτηση SortMergeJoin() και εκτυπώνονται τα αποτελέσματα.

sortMergeJoin.c:

Το αρχείο sortMergeJoin.c περιέχει αρχικά τη βασική συνάρτηση της sortMergeJoin και 2 συναρτήσεις που χρησιμεύουν στo MergeJoin, δηλαδή στη συγχώνευση 2 ταξινομημένων πινάκων, στην υλοποίηση δηλαδή του τελεστή Join. Η συνάρτηση sortMergeJoin() παίρνει από τη main τους δύο αταξινόμητους πίνακες και στη συνέχεια δημιουργεί δύο νέους ίδιου μεγέθους (R' και S') και τους ταξινομεί, χρησιμοποιώντας τη radixSort. Μετά τις 2 radixSort, οι δύο πίνακες είναι ταξινομημένοι και μπορούν να χρησιμοποιηθούν για να εκτελεστεί ο αλγόριθμος mergeJoin. Σχετικά με τη διαδικασία MergeJoin, χρησιμοποιείται η δομή resultBucket σε μία συνδεδεμένη λίστα για να αποθηκεύονται τα ταιριαστά στοιχεία των δύο πινάκων, όπου κάθε bucket μπορεί να αποθηκεύσει μέχρι 1MB μεγέθους δεδομένα και θα δεσμευτούν νέα bucket όταν η μνήμη δεν επαρκεί. Αρχικά ελέγχονται τα δυο ταξινομημένα relationships για διπλότυπα και ύστερα επιλέγεται μία μέθοδος για να βρεθούν τα κοινά τους στοιχεία. Στο τέλος της SortMergeJoin, απελευθερώνεται όλη η μνήμη για τους 4 πίνακες, αφού τα αποτελέσματα βρίσκονται στη δομή result που επιστρέφεται.

radixsort.c:

Το αρχείο radixsort.c περιλαμβάνει τη συνάρτηση radixsort(). Βασικό στοιχείο στο σκελετό της radixsort είναι η συνθήκη if, στην οποία ελέγχεται αν το μέγεθος του πίνακα που δίνεται να ταξινομηθεί είναι μεγαλύτερο ή μικρότερο από 64Kb. Αν είναι μικρότερο, ο πίνακας ταξινομείται με quicksort, αλλιώς ομαδοποιούνται τα στοιχεία του με βάση το numByte byte και η radixsort καλείται αναδρομικά για κάθε ομάδα που δημιουργήθηκε. Πιο συγκεκρημένα, για την περίπτωση των αναδρομικών κλήσεων της radixsort, αρχικά δημιουργούνται πίνακες για το ιστόγραμμα και το prefix sum. Με βάση την τιμή του numByte byte για κάθε στοιχείο του πίνακα rel1, αρχικοποείται το ιστόγραμμα και στη συνέχεια με βάση το ιστόγραμμα, αρχικοποείται και το psum. Τέλος, ξαναδιαβάζουμε τον πίνακα rel1 και με τη βοήθεια του psum, περνάμε κάθε στοιχείο του στον rel2, ο οποίος πλέον περιέχει τα στοιχεία του rel1 ομαδοποιημένα ως προς το numByte byte. Για κάθε ομάδα στοιχείων μέσα στο rel2, γίνεται και μία αναδρομική κλήση. Τα όρια της αναδρομικής κλήσης στον πίνακα δίνονται από το psum και η ομαδοποίηση στη νέα radixsort(εάν γίνει), θα γίνει με βάση το numByte+1. Τα τελικά αποτελέσματα της radixsort βρίσκονται πάντα στο rel1 της πρώτης κλήσης, στην προκειμένη περίπτωση δηλαδή στον R και S, γιαυτό και μετά από κάθε quicksort, εάν βρισκόμαστε στον R' ή στον S' γίνεται η απαραίτητη αντιγραφή.

quicksort.c:

Υλοποίηση της απλής quicksort.

testing:

Όσον αφορά το testing, εφόσον ο χρήστης το επιθυμεί, μπορεί να εκτελέσει το πρόγραμμα με την παράμετρο -t στο τέλος για να δει εάν η ταξινόμηση των πινάκων γίνεται σωστά. Ο τρόπος με τον οποίο γίνεται, είναι να εκτελείται μία quicksort για όλο τον πίνακα και στο τέλος να συγκρίνονται οι δύο πίνακες ως προς το κλειδί. Τα αποτελέσματα για το testing της radixsort βρίσκονται στο αρχείο testResults.txt

Makefile:

compile -> make all
delete .o files, output files -> make clean