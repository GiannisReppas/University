Α.Μ.: 1115201500137
Ονοματεπώνυμο: Γιάννης Ρέππας

/////////////////////////////////// Part 1 /////////////////////////////////

Αρχικά, μετά από τους μετασχηματισμούς που αναφέρονται στην εκφώνηση, η τελική γραμματική είναι αυτή που συζητήσαμε και στο μάθημα, δηλαδή η εξής:

goal -> expr
expr -> term expr2

expr2 -> + term expr2
	   | - term expr2
	   | ε

term -> factor term2

term2 -> * factor term2
	   | / factor term2
	   | ε

factor -> num
		| (expr)

Στην ουσία το num είναι τερματικό, επειδή ξέρουμε ακριβώς ότι η τιμή του είναι αριθμός από το 1 έως το 10 ,αλλά εδώ έχουμε multi-digit αριθμούς και δεν ξέρουμε τα επόμενα ψηφία.
Οπότε στην ουσία είναι σαν να έχουμε να κάνουμε με ένα "ψευδοτερματικό", αφού τα ψηφία συνεχίζονται.

Οπότε αν θέλουμε να περιγράψουμε και τους αριθμούς με πολλά ψηφία, θα μπορούσαμε είτε να αφήναμε τη γραμματική ως έχει είτε να προσθέταμε έναν νέο κανόνα για το num (όπως αναφέρεται στην εκφώνηση, αλλά και όπως εν τέλει υλοποιήθηκε και στην εργασία):

num -> digit num
	 | ε

Έτσι λοιπόν, έχοντας τη γραμματική, προχωράμε στην υλοποίηση του κώδικα.
Αρχικά διαβάζουμε την είσοδο που δίνει ο χρήστης και αφαιρόυμε όλα τα whitespaces. Τοποθετούμε τους υπόλοιπους χαρακτήρες σε μια στοίβα με τη σειρά που τους διαβάζουμε.
Για κάθε κανόνα έχουμε και μία αναδρομική συνάρτηση.
Ξεκινάμε με το goal, ο οποίος καλεί αναδρομικά το expr.
Το expr με τη σειρά του καλεί αναδρομικά τις term και expr2. Τα αποτελέσματά τους θα προστεθούν.
Ο λόγος ο οποίος προστίθενται είναι επειδή το expr δύο παράγει πρόσθεση/αφαίρεση/τίποτα, που στην ουσία είναι αντίστοιχα πρόσθεση/πρόσθεση με τον αντίστροφο/ πρόσθεση με το 0.
Η ίδια λογική ακολουθείται και με τα term και term2.
Τέλος το factor διαβάζει είτε έναν αριθμό, είτε μία παρένθεση είτε πέφτει πάνω σε parse error, μιας και οτιδήποτε πέραν αυτων των δύο δεν υποστηρίζεται.
Κάθε φορά που βρίσκουμε ένα τερματικό σύμβολο κάνουμε pop από τη στοίβα, που σημαίνει ότι στο τέλος όλων των κλήσεων η στοίβα πρέπει να είναι άδεια, διαφορετικό έχουμε πάλι ParseError.

/////////////////////////////////// Part 2 /////////////////////////////////

Makefile:

Το Makefile περιλαμβάνει 3 εντολές, την compile/all, την execute και την clean.
η compile/all μεταγλωττίζει το πρόγραμμα, η execute το εκτελεί και η clean διαγράφει τα "ανούσια" αρχεία που παράχθηκαν κατά τη μεταγλώττιση.
Θεωρούμε ότι τα απαραίτητα jar αρχεία βρίσκονται ένα φάκελο πριν από το φάκελο που εργαζόμαστε.
Η εκτέλση γίνεται ως εξής -> make execute < input.txt, όπου input.txt το αρχείο που περιέχει την είσοδο του προγράμματος και εφόσον το επιθυμούμε μπορούμε να έχουμε και αρχείο στο οποίο γράφεται η έξοδος.
Αυτό το αρχείο θα πρέπει να έχει όνομα Main.java, μιας και αυτό είναι το όνομα της κλάσης του παραγόμενου java αρχείου.
Το αρχείο εξόδο Main.java πρέπει να βρίσκεται σε διαφορετικό φάκελο από αυτόν που γίνεται η εκτέλεση ετσί ώστε το αρχείο Main.java που χρησιμοποιείται για την κατασκευή του parser να μην διαγραφτεί.
Οπότε η εντολή εκτέλεσης με έξοδο σε αρχείο θα μπορούσε να ήταν η εξής -> make execute < input.txt > ./../Main.java

scanner.flex:

Στο αρχείο αυτό βρίσκεται ο scanner/lexer. Εδώ ορίζουμε τα τερματικά σύμβολα τα οποία θα αναγνωρίζει ο parser. Τα περισσότερα σύμβολα (+ ( ) { } , if else prefix reverse) είναι απλές λέξεις οι οποίες ορίζονται σχετικά εύκολα στις γραμμές 69-79
Πέραν αυτών των συμβόλων υπάρχουν και οι συμβολοσειρές, οι indentifiers και τα whitespaces. Αυτά ορίστηκαν με τη βοήθεια των έτοιμων παραδειγμάτων που υπάρχουν στο site του μαθήματος αλλά και με τη βοήθεια παραδειγμάτων από το manual του jflex στο internet.
Αφού λοιπόν οριστούν τα tokens της γλώσσας στο αρχείο αυτό, προχωράμε στον parser.

parser.cup:

Προτού περιγραφεί η γραμματική, στην αρχή του αρχείου ορίζουμε δικές μας ματαβλητές που θα χρησιμοποιήσουμε στη συνέχεια (check_main_class, check_func_main). Στη συνέχεια, ορίζουμε τα τερματικά (που στην ουσία είναι τα tokens που περιγράψαμε πιο πριν στον scanner). Στη συνέχεια, ορίζουμε τα μη τερματικά σύμβολα, που είναι οι κανόνες της γραμματικής που περιγράφουμε στη συνέχεια. Τέλος, προτού προχωρήσουμε στη γραμματική, ορίζουμε τους κανόνες προτεραιότητας των πράξεων μεταξύ των συμβολοσειρών ( if < plus < reverse).
Η λογική της γραμματικής είναι η εξής: Στους βασικούς κανόνες, διαβάζει συνεχώς συναρτήσεις, είτε αυτές είναι κλήση είτε δήλωση συναρτήσεων. Στη συνέχεια ανάλογα, με την κατηγορία της συνάρτησης, πηγαίνουμε στον ανάλογο κανόνα (definition ή call).
Επειδή γνωρίζουμε πως η γλώσσα έχει πρώτα τη δήλωση και μετά την κλήση συναρτήσεων, το πρώτο πράγμα που κάνουμε αφού βρούμε μια δήλωση συνάρτησης είναι να ελέγξουμε εάν αυτή είναι η πρώτη. Εάν ναι, τότε εκτυπώνουμε τον ορισμό της Main class (χρησιμοποιώντας τη μεταβλητή check_main_class).
Αντίστοιχα, ακολουθούμε ίδια λογική για την εκτύπωση του ορισμού της main function, μετά από την πρώτη κλήση συνάρτησης (εκτός ενός function definition).
Όσον αφορά το parsing ενός function call ή ενός function definition ακολουθείται μια λογική επιπέδων μεβάση την προτεραιότητα των πράξεων.
Ας πάρουμε για παράδειγμα τον κανόνα function call. Τα ορίσματα μέσα σε ένα function_call ( πού είναι και το μόνο μη τερματικό σε αυτόν τον κανόνα), χωρίζονται με COMMA. Το κάθε όρισμα στη συνέχεια, αποτελείται από το πολύ ένα reverse. μετά το reverse, ακολουθεί το concatenation και μετά το concatenation το if statement, ή μία νέα κλήση συνάρτησης, ή απλά μία συμβολοσειρά. Εάν έχουμε if statement ή νέα κλήση συνάρτησης, ακουλουθείται η ίδια λογική από την αρχή.