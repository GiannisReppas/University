Ονοματεπώνυμο: Γιάννης Ρέππας
A.M.: 115201500137

compile --> make all
delete --> make clean

Μέρος Α)

Αυτό το κομμάτι της εργασίας αποτελείται από 3 αρχεία c, το mirror_client.c , το reader.c και το writter.c . Το mirror_client.c λειτουργεί πιο πολύ σαν monitor. Αρχικά κάνει τις απαραίτητες λειτουργίες για να ξεκινήσει το πρόγραμμα και στη συνέχεια ανά μερικά δυτερόλεπτα ελέγχει για νέα mirror_clients. Όταν τα βρίσκει, καλεί τα 2 προγράμματα reader και writter τα οποία υλοποιούν το βασικό κομμάτι της εργασίας, δηλαδή να μεταφέρουν τα αρχεία από το input του ενός id στο mirror του άλλου μέσω ενός fifo και με βάση το πρωτόκολλο της εκφώνησης.

Πιο συγκεκρημένα:
mirror_client.c:
Αρχικά, το mirror client χρησιμοποιεί κάπποιες global μεταβλητές και έναν signal handler. Οι global εταβλητές είναι με τη σειρά οι: α) end_check, η οποία είναι μια booloean μεταβλητή που όταν ο mirror client δεχθεί κάποιο SIGINT  κάποιο SIGQUIT, γίνεται true. Χρησιμοποίται για να τερματίζει το πρόγραμμα ομαλά. β) sigusr1_check, η οποία είναι και αυτή μια boolean μεταβλητη που γίνεται true όταν ο mirror client λάβει ένα σήμα SIGUSR1 από κάποιο reader. Χρησιμεύει για να γνωρίζει o mirror client, πότε ένας reader τερματίστηκε επειδή περίμενε για πάνω από 30 δευτερόλεπτα το pipe να δεχθεί είσοδο. γ) sigusr2_check, η οποία είναι μια boolean μεταβλητή που γίνεται true όταν ο mirror λάβει ένα σήμα SIGUSR2 άπό κάποιο reader. Βοηθάει ώστε να ο mirror client να ξέρει πότε μία μεταφορά αρχείων σε ένα pipe είχε κάποιο error, έτσι ώστε να ξαναγίνει. δ) sigusr2_counter, η οποία είναι μια int μεταβλητή που αυξάνεται κάθε φορά που ο mirror client δεχθεί ένα σήμα SIGUSR2, για την ίδια περίπτωση με το γ). Όταν αυτή η μεταβλητή γίνει ίση με 3, ο mirror client θα ξέρει ότι δεν πρέπει να ξαναδοκιμάσει να κάνει μεταφορά αρχείων. Όλες οι παραπάνω λειτουργίες υλοποιούνται από το signal handler.

Όσον αφορά την κανονική λειτουργία του, το mirror client ελέγχει αν τα δεδομένα που έδωσε ο χρήστης από τη γραμμή εντολών είναι τα σωστά και αν αν ναι, τα αποθηκεύει στις κατάλληλες μεταβλητές. Στη συνέχεια, αυτό που κάνει είναι να ενημερώσει το log_file ότι κάποιος mirror client έφυγε από το σύστημα ( εκτενείς πληροφορίες για το log_file στο μέρος Γ) ). Στη συνέχεια, κάνει το πρώτο βήμα της εκφώνησης, δηλαδή πάει στο common_dir και γράφει ένα αρχείο με όνομα το id του και την κατάληξη .id και μέσα στο αρχείο τον process id της διεργασίας του mirror_client. Ελέγχεται και αν το αρχείο υπάρχει ήδη, επειδή δεν μπορούν να γίνουν 2 mirror clients με το ίδιο id. Μετά από αυτό ξεκινάει και η βασική διαδικασία του mirror client που είναι το monitoring ανά τακτά χρονικά διαστήματα και η κλήση των writter και reader.

Η συνάρτηση execute mirro client έχει αρχικά ένα μεγάλο while loop το οποίο ανά μερικά δευτερόλεπτα που γίνονται defined με το SECONDS ελέγχει την ύπαρξη νέων ids στο common_dir. Αυτό επιτυγχάνεται με τη χρήση των συναρτήσεων alarm και pause. Αν η pause διακοπεί από κάποιο SIGALRM, ο έλεγχος συνεχίζεται κανονικά, αν όμως διακοπεί λόγω κάποιας SIGINT ή SIGQUIT, τότε αναγκαστικά η global μεταβλητή γίνεται true και το πρόγραμμα τερματίζει. Ο τερματισμός το προγράμματος γίνετια με τη συνάρτηση end_mirrro_client( δες παρακάτω). Ο έλεγχος έχει ως εξής: Έχουμε έναν πίνακα visited, ο οποίος έχει όλα τα ids που έχουμε ήδη επεξεργαστεί με αυτό το mirror client. Ελέγχουμε σε κάθε έλεγχο όλα τα αρχεία που βρίσκονται στο φάκελο common_dir. Αν το αρχείο είναι id file(μπορεί να είναι και fifo όπως θα δούμε στα writter και reader), τότε ελέγχουμε αν το id αυτό βρίσκεται μέσα στον πίνακα visited. Αν δε βρίσκεται, τότε σημαίνει πως έχουμε καινούριο id όση ώρα περιμέναμε και πρέπει για αυτό το id να καλέσουμε τα ritter και reader. Ο γονιός mirror client λοιπόν καλεί τα παιδιά του writter και reader και περιμένει να ολοκληρωθούν για να συνεχίσει τον έλεγχο. Τα παιδιά καλούνται με fork() και exec().

Όσον αφορά τώρα τη λήξη του mirror client, αυτή γίνεται όταν ο mirror client δεχθεί όπως αναφέραμε πιο πριν ένα SIGINT ή SIGQUIT και φύγει από το μεγάλο while loop στην συνάρτηση execute mirror client. Μετά από αυτό λοιπόν, θα εκτελεστεί και η τελευταία συνάρτηση της main, η end_mirror_client. Η end_mirror_client αρχικά διαγράφει το mirror directory του mirror client. Αυτό επτυγχάνεται με την αναδρομική συνάρτηση delete_all_folder_files, ο οποία λαμβάνει ως ορίσμα έναν φάκελο και διαγράφει με τη remove όλα του τα αρχεία. Σε περίπτωση που βρει έναν φάκελο, καλεί τον ευατό της για το φάκελο που βρήκε. Έτσι λοιπόν μετά την εκτέλεση της delete_all_folder_files, ο φάκελος που δόθηκε είναι κενός και μπορεί να διαγραφτεί με την rmdir. Αφού διαγραφεί ο mirror_dir, διαγράφεται και το id file στο common_dir.

writter.c:
Ο writter αναλαμβάνει την αντιγραφή των αρχείων από το input dir στο fifo. Αρχικά δημιουργεί το fifo (αν δεν έχει ήδη δημιουργηθεί από το reader ενός άλλου mirror client) και το ανοίγει με write only mode. Έτσι, έχοντας το input dir ξεκινάει να γράφει τα αρχεία στο pipe με βάση το πρωτόκολλο που περιγράφεται στην εκφώνηση. Μετά από κάθε write, ενημερώνεται κατάλληλα το log_file για τα bytes και τα files που γράφτηκαν. Ο τρόπος που αποθηκεύεται το directory στο fifo είναι ακριβώς όπως και το file, απλά προφανώς χωρίς τα 2 τελευταία βήματα του πρωτοκόλου. Καταλαβαίνουμε ότι έχουμε να κάνουμε με directory και όχι με file, με τη βοήθεια της opendir, η οποία επιστρέφει NULL αν το directory που της δίνουμε να ανοίξει δεν υπάρχει.

reader.c:
Δουλεία του reader είναι να κάνει το αντίστροφο του writter, δηλαδή να πάρει τα δεδομένα από το fifo και να τα αποθηκεύσει στο mirror_dir. To fifo ανοίγει με την ίδια διαδικασία που ακολουθήσαμε και με το writter. Στην αρχή όμως, προτού ξεκινήσουμε να διαβάζουμε, ελέγχουμε αν το fifo έχει έστω και έναν χαρακτήρα γραμμένο σε αυτό, διαφορετικά περιμένουμε για 30 δευτερόλεπτα. Η αναμονή αυτή επιτυγχάνεται με τη βοήθεια της συνάρτησης poll που έχουμε διδαχθεί από τις διαφάνειες. Αν περάσουν 30 δευτερόλεπτα και το fifo είναι ακόμα άδειο, τότε ο reader τερματίζεται και στέλενει SIGUSR1 στον γονιό του, mirror client. Ο mirror client με τη σειρά του, με τη διαδικασία που αναφέραμε πιο πριν θα συνεχίσει το έλεγχο και δε θα δώσει ξανά σημασία στην αποτυχημένη σύνδεση, της οποίας κιόλας το pipe διαγράφτηκε. Αν το fifo δεν είναι άδειο, τότε σημαίνει πως μπορούμε να ξεκινήσουμε τη βασική λειτουργία του reader. O reader, σαν αντίστροφος του written θα χρησιμοποιήσει το ίδιο πρωτόκολλο από την ανα΄ποδη πλερά και θα αρχίσει να διαβάζει αρχεία από το pipe. Αναγνωρίζουμε και εδώ αν το όνομα που έχουμε έχει να κάνει με αρχείο ή φάκελο με την opendir. Και εδώ, μετά από κάθε read το log_file ενημερώνεται κατάλληλα. Αν μία read επιστρέψει -1, τότε σημαίνει πώς απέτυχε για κάποιο λόγο(λογικά επειδή ο reader λειτούργησε πιο γρήγορα από τον writter και το fifo άδειασε). Τότε, είμαστε στην περίπτωση που ο reader πρέπει να τερματίσει και να στείλει μήνυμα στον mirror client ότι υπήρξε πρόβλημα στη μεταφορά. Το fifo διαγράφεται και αν η ίδια διαδικασία δεν έχει γίνει άλλες 2 φορές, η όλη διαδικασία θα επαναληφθεί από το mirror client, όπως περιγράφτηκε παραπάνω. Ωστόσο, η περίπτωση θα είναι ελαφρώς διαφορετική από την αρχική. Από τη στιγμή που δε γνωρίζουμε τί απέγινε με την ανάποδη αλληλεπίδραση των 2 mirror clients, o mirror client πουδέχεται το σήμα(πατέρας του reader) πρέπει να εκτελέσιε ΜΟΝΟ το reader του και ο πατέρας του writter να εκτελέσει ΜΟΝΟ το writter. Για να μην δημιουργηούν προβλήμτα κάνουμε τον εξής μετασχημετισμό: Στην αρχή της εκτέλεσης του mirror client, όταν γράφουμε το process id στο id file, γράφουμε και το input dir και το log_file του. Αυτό μας επιτρέπει απαξ και βρούμε το id file, να εκτελέσουμε τον writter και τον reader μαζί. Έτσι σε περίπτωση λάθους, ο writter και ο reader εκτελούνται ξανά από το ίδιο mirror client

Μέρος Β)

Το script ακολουθεί την εκφώνηση βήμα βήμα. Χρησιμοποιεί δύο extra αρχεία c , τα οποία εκτυπώνουν τυχαίες συμβολοσειρές από 1 έως 8 χαρακτήρες και κείμενα από 1024 μέχρι και 1024*128 bytes
Το πιο δύσκολο κομμάτι του script είναι η δημιουργία των directories. Έχοντας μια λίστα με όλα τα ονόματα των directories, έχουμε σε κάθε loop που δημιουργεί το directory ένα path, το οποίο για κάθε directory πεκτείνετια μέχρι να φτάσουμε σε μήκος path ίσο με το level, όπου τότε το path έχει ξανά μήκος 0. Απαγορεύεται ο χρήστης να δώσει level  και όλα τα irectories και τα files ξεκινούν από το level ένα. Αφού έχουμε όλα τα paths των directories σε έναν πίνακα αποθηκευμένα, η διαδικασία δημιουργίας των αρχείων είναι σχιτικά απλή, αφού για κάθε στοιχείο του πίνακα προστίθεται το όνομα του αρχείου και έτσι έχουμε τα αρχεία τοποθετημένα με σειρά round-robin, αφού τοποθετήκαν οι φάκελοι με την ίδια σειρά στον πίνακα. 

Μερος Γ)

Κάθε φορά που το log_file ενός mirror client ενημερώνεται, ανάλογα με τον τύπο της ενημέρωσης, στην αρχή κάθε γραμμής έχει ένα ανγνωριστικό χαρακτήρα. Πιο συγκεκρημένα:
Γραμμή που αρχίζει από 1 --> αναφέρεται σε bytes written
					   2 --> αναφέρεται σε files wriiten
					   3 --> αναφέρεται σε bytes read
					   4 --> αναφέρεται σε files read
					   5 --> αναφέρεται σε connection μεταξύ 2 mirror clients
					   6 --> αναφέρεται σε mirror client που έφυγε από το σύστημα.
Έτσι λοιπόν, διαβάζουμε το log file γραμμή-γραμμή και με βάση τον πρώτο χαρακτήρα της κάθε γραμμής κάνουμε τις κατάλληλες επιλογές. Όλα τα υπόλοιπα φαίνονται αναλυτικά στα σχόλια του script
