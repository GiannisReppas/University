Ονοματεπώνυμο: Γιάννης Ρέππας
Α.Μ.: 1115201500137

Συναρτήσεις integer_to_string και number_of_digits():

Το πρόγραμμα που εκτελέιται από το command line είναι το myfind και μέσα στον κώδικα, με τη βοήθεια της ενολής execlp() , εκτελούνται τα προγράμματα spliter_merger και leaf_node.
Για αυτό το λόγο χρησιμοποιούμε τις συναρτήσεις integer_to_string() και number_of_digits() για να μετατρέπουμε αριθμούς σε συμβολοσειρές και να μετράμε τον αριθμό των ψηφίων τους
έτσι ώστε να δεσμεύουμε δυναμικά το χώρο που χρειάζεται για να τις αποθηκεύσουμε αντίστοιχα.

myfind.c - 1st part:

Στο αρχείο myfind.c υπάρχει ο κώδικας της διεργασίας root. Αρχικά, ξεκινάμε να μετράμε το χρόνο που θα τρέξει αυτή η διεργασία. Στο τέλος της main, εκτυπώνεται ο χρόνος. Πρώτο
πράγμα που κάνουμε είναι να ελέγξουμε εάν ο χρήστης κάλεσε σωστά το πρόγραμμα από τη γραμμή εντολών. Για παράδειγμα, αν το ύψος του δέντρου που δώθηκε από τη γραμμή εντολών
είναι μεγαλύτερο του 5, το πρόγραμμα τερματίζει και εμφανίζει μήνυμα λάθους. Στη συνέχεια, ορίζεται ο signal_handler για το σήμα SIGUSR2, το οποίο στέλνεται στη root από κάθε
leaf_node. Ο signal_handler μετράει με τη βοήθεια ενός counter τον αριθμό των σημάτων που έλαβε και τον εμφανίζει λίγο πριν τερματίσει. Ο ορισμός του signal_handler γίνεται με
τη βοήθεια της sigaction, έτσι ώστε να μην έχουμε προβλήματα με write και read που γίνονται τη στιγμή που ένα SIGUSR2 στέλνεται στη root. Στη συνέχεια, αποθηκεύουμε σε μεταβλη-
τές τα στοιχεία που έδωσε ο χρήστης από τη γραμμή εντολών(τώρα ξέρουμε ότι είναι σωστά). Στη συνέχεια, αφού φτιάξουμε και ένα pipe για την επικοινωνία της root με την πρώτη
spliter-merger, κάνουμε fork() και δημιουργούμε την πρώτη spliter-merger. Η root ίσως εκτελεστεί μέτα,παράλληλα ή και πριν τη πρώτη spliter-merger. Εμείς θέλουμε να εκτλεστεί
μετά την πρώτη spliter-merger, γι' αυτό το λόγο κάνουμε wait(NULL) στη root. Έτσι πρώτα θα γραφτούν τα δεδομένα στο pipe από τα leaf_nodes και μετά θα γίνει η ανάγνωσή τους 
από τη root. Για να γίνει πιο κατανοητή η λειτουργία των διεργασιών, θα αναλυθεί πρώτα η λειτουργία των spliter-mergers και leaf_node και στη συνέχεια θα ανλυθεί η συνέχεια 
της root.

spliter-merger.c - 1st part:

Όπως και στη myfind, έτσι και εδώ το πρώτο που κάνομε είναι να ξεκινήσουμε να μετράμε το χρόνο εκτέλεσης της διεργασίας και να πάρουμε τα δεδομένα που δώθηκαν στην εντολή
εκτέλεσης των spliter-mergers. Στη συνέχεια, προτού κάνουμε fork() για νέες spliter-mergers ή για leaf_nodes, μετατρέπουμε το range σε αυτό που θα ψάξουν τα leaf_nodes, σε
περίπτωση που το height είναι 1. Ανάλογα με την τιμή του -s( αν δόθηκε ή αν δε δόθηκε από το χρήστη) ακολουθείται διαφορετικός αλγόριθμος. Αν το -s δε δόθηκε, τότε το διάστημα
που έχουμε, διαιρέιται σε δύο ίσα μέρη και το κάθε ένα περνιέται σαν όρισμα στη νέα διεργασία. Αντίθετα, αν το -s δίνεται από το χρήστη, δε γίνεται κάτι τέτοιο. Στην ουσία, η
κάθε διεργασία leaf_node, έχει ένα συγκεκρημένο αύξοντα αριθμό, από την πρώτη, μέχρι και την τελευταία. Αυτό το νούμερο περνάμε ουσιαστικά στην επόμενη διεργασία παιδό και αν
αυτή είναι lead_node, τότε στο leaf_node γίνεται ο υπολογισμός του διαστήματος. Στη σνέχεια, κάνουμε δύο fork() και δημιουργούμε τα παιδιά της spliter-merger. Για τον ίδιο λόγο
που αναφέρθηκε και στο κείμενο myfind.c - 1st part , θα αναλύσουμε πρώτα τη λειτουργία του leaf_node και μετά θα συνεχίσουμε με το υπόλοιπο μέρος της spliter-merger.

leaf_node.c:

Και εδώ, το πρώτο πράγμα που κάνουμε είναι να πάρουμε τα δεδομένα που έδωσε ο χρήστης και να ξεκινήσουμε να μετράμε το χρόνο της διεργασίας. Στη συνέχεια, υπολογίζεται το διάστημα
αναζήτησης στο αρχείο, (σε περίπτωση που δώθηκε η επιλογή -s) και ξεκινάμε την αναζήτηση. Η διαδικασία αναζήτησης έχει ως εξής: Μέσα στο range του αρχείου που ψάχνουμε, διαβάζουμε
μία εγγραφή από αυτό. Αν το pattern που δώθηκε από το χρήστη υπάρχει έστω και σε ένα χαρακτηριστικό της, τότε αυτή προστίθεται σε ένα πίνακα από εγγραφές, ο οποίος δημιουργείται,
επεκτείνεται και απελευθερώνεται δυναμικά. Ο λόγος που κάνουμε κάτι τέτοιο, αντί να περάσουμε την εγγραφή κατευθείαν στο pipe επικοινωνίας με τη spliter-merger, είναι επειδή θέλουμε
να περάσουμε πρώτα στο pipe το συνολικό αριθμό εγγραφών που βρήκαμε σε αυτό το διάστημα, το μέγεθος δηλαδή του δυναμικό πίνακα. Αφού περάσουμε αυτό τον αριθμό, τότε ξεκινάμε να περνά-
με και τις εγγραφές. Στη συνέχεια, με την ίδια λογική γράφουμε στο pipe το χρόνο εκτέλεσης της διεργασίας leaf_node. Εδώ όμως γνωρίζουμε ήδη τον αριθμό των χρόνων( 1 ) , οπότε 
απλά γράφουμε 1 και στη συνέχεια το χρόνο εκτέλεσης της διεργασίας. Τέλος, στέλνουμε και το σήμα SIGUSR2 στη root, με την εντολή kill.

spliter-merger.c - 2nd part:

Αυτό το κομμάτι της spliter-merger θα εκτελεστεί αφού έχουν ολοκληρωθεί τα παιδιά της, τα οποία είναι είτε leaf_nodes είτε άλλα spliter-mergers. Έτσι λοιπόν, έχουμε 2 pipes, τα οποία
έχουν εγγραφές και χρόνους εκτέλεσης. Αυτά τα δεδομένα πρέπει να τα περάσουμε μαζί σε ένα pipe, με την ίδια μορφή. Οπότε αρχικά, όσον αφορά τις εγγραφές, διαβάζουμε τον αριθμό΄των
εγγραφών μέσα στα δύο pipes. Προσθέτουμε τους δύο αυτούς αριθμούς και γράφουμε το αποτέλεσμα στο νέο pipe. Αυτός ο αριθμός θα είναι ο συνολικός αριθμός των εγγραφών μέσα στο 
νέο pipe. Στη συνέχεια, περνάμε και τις εγγραφές στο νέο pipe. Με αντίστοιχο τρόπο περνάμε στο νέο pipe και τους χρόνους εκτέλεσης των leaf_nodes που ακολουθούν. Τέλος, πρέπει να
περάσουμε στο νέο pipe και το χρόνο εκτέλεσης του spliter-merger, μαζί με τα παιδιά του( αν υπάρχουν).

myfind.c - 2nd part:

Αντίστοιχα, αυτό κομμάτι της myfind θα εκτελεστεί μόνο όταν έχει ολοκληρωθεί η αναζήτηση, με τα αποτελέσματά της να υπάρχουν στο pipe επικοινωνίας της root με τη spliter-merger. Οπότε 
λοιπόν, με τον ίδιο χρόνο που αναφέρθηκε και στη spliter-merger, διαβάζουμε τις εγγραφές ( τις οπόιες γράφουμε σε ένα αρχείο results.txt) και τους χρόνους εκτέλεσης(για τους οποίους 
βρίσκουμε min,max και χρόνους εκτέλεσης, τους οποίους εκτυπώνουμε). Τέλος κάνουμε fork() για να καλέσουμε την εντολή συστήματος sort. Η sort ταξινομεί τα αποτελέσματα σε αύξουσα σειρά
με βάση το id τους και εκτυπώνει τα αποτελέσμτατα. Επίησς, η root θα εκτυπώσει το χρόνο της, τον αριθμό των σημάτων που έλαβε από τα leaf_nodes και θα απελευθερώσει δυναμικά όση μνή-
μη δέσμευσε.