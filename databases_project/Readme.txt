Ονοματεπώνυμα: Γίάννης Ρέππας, Γιάννης Τασσόπουλος
Α.Μ.: 1115201500137, 1115201500155

Συνάρτηση main: Λειτουργεί με παρόμοιο τρόπο με την ht_main_test.c που ανέβηκε στο eclass. Είναι φτιαγμένη έτσι ώστε να ικανοποιούνται τα 6 σημεία που αναφέονται στην εκφώνηση. Στη γραμμή ορισμάτων πρέπει να δωθεί ένα από τα αρχεία πο μας δώθηκαν (records1K.txt, records5K.txt, records10K.txt, records15K.txt). Αρχικά κάνουμε εισαγωγή τις μισές εγγραφές του αρχείο στο πρωτεύον ευρετήριο. Ψάχνουμε στη συνέχεια για εκείνες που έχουν ζυγό id. Μετά, κάνουμε εισαγωγή τις άλλες μισές και στο πρωτεύον και στο δευτερεύον ευρετήριο και κάνουμε αναζήτηση αυτές των οποίων το όνομα για 6ο χαρακτήρα έχει τον αριθμό 2.

Συνάρτηση ht_main_test.c: Η συνάρτηση που ανέβηκε στο eclass

HashStatistics: Αρχικά, με την κλήση των δύο συναρτήσεων OpenIndex για κάθε ευρετήριο, βρίσκουμε εάν το αρχείο είναι πρωτεύον ή δευτερεύον. Στη συνέχεια, υπολογίζονται τα στατιστικά. Όλα τα στατιστικα υπολογίζονται παράλληλα και στο τέλος εκτυπώνονται το ένα μετά το άλλο. Η διαδικασία που ακολουθούμε είναι να έπισκεπτόμαστε πρώτα όλα τα blocks του Hash Table και στη συνέχεια όλα τα blocks δεδομένων. Αφού αρχικά επισκεφτούμε όλα τα blocks του Hash Table, θα έχουμε ένα πίνακα με όλους τους pointers των buckets. O τρόπος με τον οποίο υπολογίζουμε το πρώτο στατιστικό είναι να έχουμε ένα μετρητή για τα blocks που επισκεπτόμαστε και για κάθε BF_ReadBlock που κάνουμε να τον αυξάνουμε κατά ένα. Για το δεύτερο στατιστικό, έχουμε ένα πίνακα με μέγεθος numBuckets για κάθε bucket και για κάθε επανάληψη, δηλαδή για κάθε ακολουθία από block δεδομένων, αυξάνουμε τον αριθμό του κάθε πεδίου τπυ πίνακα κατά currentRecords για το κάθε block που επισκεπτόμαστε. Στο τέλος, βρίσκουμε την ακολουθία από blocks δεδομένων με τις λιγότερες και τις περισσότερες εγγραφές και το μ.ο. Το στατιστικό 3 υπολογίζεται με τον ίδιο τρόπο που υπολογίζουμε και το στατιστικό 2, όμως αντί να έχουμε πίνακα με μετρητές για εγγραφές έχουμε πίνακα με μετρητές για blocks δεδομένων. Το στατιστικό 4, στην ουσία το έχουμε έτοιμο από το στατιστικό 3, γιατί στην ουσία τα block υπερχείλισης για κάθε bucket είναι όλα τα block δεδομένων του , με εξέρεση το αρχικό.

HT_CreateIndex: Αρχικά δημιουργούμε ένα αρχείο με την BF_CreateFile και το ανοίγουμε με την BF_OpenFile. Στη συνέχεια, δημιουργούμε το Hash Table. Ο αριθμός των block του Hash Table έχει να κάνει με τον αριθμό των block. Κάθε block του Hash Table στην αρχή έχει ορισμένα δεδομένα για το ευρετήριο: Index Type( 'p' για πρωτεύον, 's' για δευτερον), attrType, attrName, attrLength, numBuckets. Μετά από αυτά τα δεδομένα, υπάρχουν τα buckets. Αν τα buckets είναι τόσο πολλά που δε χωράνε σε ένα block, δεσμεύουμε νέο block και επαναλαμβάνεται η ίδια διαδικασία μέχρι να τοποθετήσουμε όλα τα buckets στο Hash Table. Στην ουσία, τα buckets είναι pointers σε block δεδομένων, οπότε το κάθε bucket είναι ένας integer. Η αρχική τιμή
που έχουν όλα τα buckets είναι -1, αφού δε δείχνουν σε κανένα block δεδομένων όταν το Hash Table δημιουργείται. Στο Τέλος της συνάρτησης, κλείνουμε το αρχείο που ανοίξαμε και δημιουργήσαμε.

HT_OpenIndex: Στην αρχή ανοίγουμε το αρχείο και στη συνέχεια δεσμεύουμε δυναμικά την δομή HT_info και τη αρχικοποιούμε. Ο τρόπος με τον αποίο την αρχικοποούμε είναι διαβάζοντας τα δεδομένα από το block 0. Στο τέλος επιστρέφουμε τη δομή αυτή.

HT_InsertEntry: Αρχικά, ανάλογα με το attrType, καλούμε την κατάλληλη συνάρτηση κατακερματισμού. Η συνάρτηση κατακερματισμού που χρησιμοποιούμε είναι η universal hashing. Έτσι, γνωρίζουμε τον αριθμό του bucket στο οποίο θα τοποθετηθεί η εγγραφή. Ο τρόπος με τον οποίο παίρνουμε τον pointer που δείχνει αυτό το bucket είναι ο εξής. Υπολογίζουμε τον αριθμό των buckets που υπάρχουν σε κάθε block του Hash Table. Με αυτόν τον τρόπο, επισκεπτόμαστε κατευθείαν το σωστό bucket χωρίς να χρειαστεί να επισκεφτούμε όλα τα block του Hash Table ( Ο(1) πολυπλοκότητα). Στη συνέχεια, ελέγχουμε αν υπάρχει ήδη κάποιο block δεδομένων στο bucket και αν δεν υπάρχει, το δημιουργούμε. Η δομή που έχει ένα block δεδομένων είναι η εξής: pointer στο επόμενο block δεδομένων, αριθμός εγγραφών στο block τη χρονική στιγμή που το επισκεπτόμαστε και μέγιστος αριθμός εγγραφών που μπορούν να χωρέσουν στο block. Τέλος, εκετελείται η εισαγωγή, δηλαδή αρχίζουμε να ψάχνουμε στη σειρά όλα τα blocks δεδομένων και με το που βρούμε κάποιο το οποίο έχει κενό χωρο ( δηλαδή currentRecords < maxRecords), τοποθετούμε σε αυτό την εγγραφή. Η εγγραφή θα τοποθετείται πάντα στην πρώτη διαθέσιμη  θέση μετά τις ήδη υπάρχουσες εγγραφές. Τέλος, σε περίπτωση που το block δεδομένων γέμισε με εγγραφές και δεν υπάρχουν άλλα blocks μετά από αυτό, δημιουργείται block υπερχείλησης.

HT_GetAllEntries: Πηγαίνουμε στο πρώτο block δεδομένων του bucket στο αοποίο αντιστοιχεί η εγγραφή προς αναζήτηση, με τον ίδιο ακριβώς τρόπο όπως και στην HT_Insertentry. Εδώ όμως, αντί να δημιουργούμε νέα blocks ή να τοποθετούμε εγγραφές στα blocks δεδομένων, αναζητούμε την εγγραφή που θέλουμε και μόλις τη βρούμε εκτυπώνουμε όλα τα πεδία της.

HT_DeleteEntry: Ακολουθούμε την ίδια ακριβώς διαδικασία με την HT_GetAllEntries, αλλά αντί να εκτυπώσουμε την εγγραφή που ψάχνουμε, μόλις τη βρούμε τη διαγράφουμε. Ο τρόπος που τη διαγραφουμε είναι τέτοιος ώστε να τηρηθούν οι προδιαγραφές του block δεδομένων, δηλαδή ανημερώνεται η δεύτερη μεταβλητή στην αρχή του ( currentRecords) και αφού διαγραφεί, εάν μετά από αυτή στο ίδιο block υπάρχουν και άλλες εγγραφές, μεταφέρεται η κάθε μία από αυτές μία θέση προς τα πίσω.

SHT_CreateSecondaryIndex: Η secondary create στο πρώτο μέρος της είναι πρακτικά σχεδόν ίδια με την HT_CreateIndex με την διαφόρα στο ότι βάζουμε το ht fileName. Στο δεύτερο μέρος πέρνουμε όλες τις εγγραφές που έχει η primary βαση και τις εισάγουμε στην secondary βαση. Ο τρόπος που το κάνουμε είναι ότι έχουμε ορίσει την primaryFileDescriptor σαν μια extern μεταβλητή όπου της δίνουμε το αρχείο της HT ώστε να μπορούμε μέσα στην secondary create να παρουμε αρχικά πόσα buckets περιέχει και μετά με μια for() κάνουμε την αντιγραφή των εγγραφών με την παραπάνω πληροφορία σε ποιο block βρισκεται στην primary βάση.

SHT_info* SHT_OpenSecondaryIndex: Λειτουργεί με τον ίδιο τρόπο με την HT_OpenIndex προσαρμοσμένη για την secondary βαση.

SHT_CloseSecondaryIndex: Σε αυτή την συνάρτηση κλείνουμε το αρχείο με την βοήθεια της BF_CloseFile() και έπειτα αποδεσμεύουμε την μνήμη από αυτό που κλείσαμε.

SHT_SecondaryInsertEntry: Στην secondary insert δεν χρειάζετε να ελέγξουμε το attrType διότη σίγουρα το hashing θα γίνει για string. Όπως και στις αλλες συναρτήσεις ο κώδικας ειναι ίδιος με την HT_InsertEntry αλλα προσαρμοσμένος για την secondary βαση. 

SHT_SecondaryGetAllEntries: Αντίστοιχα με την HT_GetAllEntries εκτυπώνουμε την εγγραφή με όλα τα πεδία της και επιστρέφουμε και blocks που διαβάστηκαν μέχρι να βρεθούν όλες οι εγγραφές.